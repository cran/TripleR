%\VignetteIndexEntry{Introduction to TripleR: Social Relations Analyses in R}
%\VignetteDepends{lme4}
\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{tabulary}
\usepackage{tocloft}
\usepackage{relsize}
\usepackage{hyperref}
\usepackage{apacite}

%-----  Customization & setup --------------------

\hypersetup{linktocpage}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=blue
}
\renewcommand{\cftsecdotsep}{\cftdotsep}  % damit auch die Hauptsections im TOC Punkte zu den Seitenzahlen haben

\SweaveOpts{prefix.string=Sweave-Files/Sw_} 	% Put R plots into a sub-directory
\SweaveOpts{keep.source=TRUE} 					% keep comments in source code

% R ouput should be only 80 characters wide
<<echo=false>>= 
options(width=90) 
@ 
%--------------------------------------------------	








\title{Round robin analyses in R: How to use TripleR}
\author{Felix D. Sch\"onbrodt\footnote{\copyright~\today,~Felix Sch\"onbrodt, Department of Psychology, Ludwig-Maximilians-University, Germany. This package partly was written during a Google Summer of Code 2010 project. Comments on this document may be sent to the author at felix@nicebread.de.}}



\begin{document}	

	% Set new styles for the R output - 
	% see: http://www.stat.auckland.ac.nz/~stat782/downloads/Sweave-customisation.pdf
	% see: http://www.stat.berkeley.edu/users/sandrine/Docs/Papers/Bios06/SurvivalEnsembles.Rnw
	% Has to bee after \begin{document}
	
	\DefineVerbatimEnvironment{Sinput}{Verbatim} {	fontfamily=courier, 
													baselinestretch=1, 
													fontsize=\relsize{-1}}
	\DefineVerbatimEnvironment{Soutput}{Verbatim} {	fontfamily=courier, 
													baselinestretch=1, 
													fontsize=\relsize{-1}}
	\DefineVerbatimEnvironment{Scode}{Verbatim} {	fontfamily=courier, 
													baselinestretch=1, 
													fontsize=\relsize{-1}}													
	
	\fvset{listparameters={\setlength{\topsep}{0pt}}}
	\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}
	%--------------------------------------------------	
	
	
	
	
	
\maketitle
\tableofcontents
\setcounter{tocdepth}{2}
\clearpage

TripleR\footnote{When you use TripleR in your research, please cite it as 
<<echo=false,results=tex>>=
g1 <- gsub("&", "\\&", attr(citation("TripleR")[[1]], "textVersion"), fixed=TRUE)
g2 <- gsub("รถ", "\\\"o", g1, fixed=TRUE)
cat(g2)
@
} provides functions with a simple, yet powerful interface to calculate round robin analyses in R. We assume that you are already familiar with social relations analyses. If not, a good starter would be David Kenny's website\footnote{http://davidakenny.net/kenny.htm}, or some introductory articles (e.g., \citeNP{Backinpress}; \citeNP{Kenny2006}, especially Ch. 8; \citeNP{Kenny1994}, for detailed description of the model and the formulae). 

If you have already done your round robin study, this document will explain how to get your data into the right format, how to tell TripleR what analyses to do, and how to work with the results. In social relations analyses (SRAs), two notations for the different roles are common. If the investigated phenomenon is a behavior, one usually speaks of \emph{actors} and \emph{partners}. If the investigated phenomenon is interpersonal perception, one speaks of \emph{perceivers} and \emph{targets}. Both groups of labels are interchangeable; in the remainder of this document (as well as in the help files), we will always call them actors and partners.

\section{Getting the data into the right format} 
In dyadic data analyses, one often finds two data formats: either the ``wide format'', in which each row is one participant, multiple variables or measurements are stored in multiple columns. Concerning round robin data, this would lead to a quadratic matrix with actors as rows and partners as columns. If we have a group of 5 people who rate how much they like each other, the data matrix would look like:

<<echo=false>>=
	library(TripleR)
	set.seed(0xbeef)
	n <- 5
	mat1 <- matrix(round(runif(n^2)*6), nrow=n)
	diag(mat1) <- NA
	colnames(mat1) <- rownames(mat1) <- LETTERS[1:n]
	mat1
@



The most flexible data format, however is the ``long format''. In this format each observation is one row, which would look like:

<<echo=false>>=
	mat1.long <- TripleR:::matrix2long(mat1, new.ids=FALSE)
	mat1.long
@


The long format has several advantages:
\begin{itemize}

	\item Several variables can be stored in one data structure (instead of putting each variable into another quadratic matrix)

	\item Several groups can be stored in the same data structure by an column indicating the group id

	\item The data format can be more efficient, as missing values just are missing, and do not occupy a NA place in the matrix (however, as actor ids and partner ids need their own column, the long format has some overhead)
	
	\item Data input can be easier, as the order of rows in long format is arbitrary. Each data row is uniquely identified by their actor id and partner id, hence it does not matter whether data entries are grouped along the partner id (as in the example above). You can also group them along the actor id (which could be favorable, as for example the data from one perceiver are typed in one block), or do not group them at all. If you find a lost questionnaire, you can just append it at the end of the long format data frame, regardless of what happend in between.
\end{itemize}


If the example data set from above would be extended to multiple groups and multiple variables, it would look like:

<<echo=false>>=
	mat2 <- matrix(round(runif(n^2)*6), nrow=n)
	diag(mat2) <- NA
	colnames(mat2) <- rownames(mat2) <- LETTERS[(n+1):(2*n)]
	mat2.long <- TripleR:::matrix2long(mat2, new.ids=FALSE)
	long3 <- rbind(mat1.long, mat2.long)
	long3 <- cbind(long3, value2 = round(runif(n*2)*6), group.id=c(rep(1,n^2), rep(2,n^2)))
	long3$value2[long3$actor.id==long3$partner.id] <- NA
	long3
@



Note: The rows where actors == partners (which contain NAs in all measured variables) could have been omitted in the long format. They are only kept for illustration. Furthermore, if you assess self ratings (which would naturally be stored in these fields) they can stay in the data set. These values are automatically set to NA prior to performing the SRAs.


To summarize, for TripleR we need data in the long format. We need at least 3 columns: the actor id, the partner id, and the variable. If multiple variables are assessed, they are coded in a separate column. If multiple groups are assessed, the group id goes into another column. Actor and partner ids have to be unique within each group (i.e., person in different groups can have the same id. To avoid confusions, however, it might be preferable to assign person ids which are unique for the whole data set). Throughout this documentation, the column indicating the actor id is called \texttt{actor.id} (the other id columns respectively). Note, however, that you can assign any other name to these columns.

\section{How to do the analyses}
TripleR is capable of doing 4 different types of analyses\footnote{Please make sure that you use the most recent version of TripleR (this document was built using TripleR \Sexpr{installed.packages()["TripleR","Version"]}). You can check the installed version using \texttt{sessionInfo()}. You can install the latest stable version from CRAN: \texttt{install.packages("TripleR", dependencies=TRUE)}. Or, if you are brave, you can install the current developer version from R-Forge: \texttt{install.packages("TripleR", repos="http://R-Forge.R-project.org", dependencies=TRUE)}. But be aware that these developer versions might be buggy or produce wrong results. For productive use, we only recommend to use the stable version on CRAN. TripleR depends on some other packages (\texttt{reshape}, \texttt{plyr}, and \texttt{ggplot2}), which have to be installed on your system as well. The parameter \texttt{dependencies=TRUE} forces \texttt{R} to install these additional packages automatically.}:
\begin{itemize}

	\item Univariate manifest analyses (i.e., one measured variable)

	\item Univariate latent analyses, where two manifest variables are indicators for one latent construct (in the current version, only two manifest variables are possible. Future versions may be able to process an unlimited number of indicators)

	\item Bivariate manifest analyses (i.e., two measured variables, which are correlated within the SRM)

	\item Bivariate latent analyses, where each two manifest variables define one latent construct
\end{itemize}


All of these analyses are possible in a single group (in this case, within group tests for significance are employed), or with multiple groups (in this case, between group t-tests, weighted for group size, are employed).


In the following paragraphs, all four analyses will be shown. Therefore, we load a built in data set from the package. This data set comes from the `Mainz Freshman Study', which assessed liking (`How much do you like X?') and meta-liking (`How much, do you think, does X like you?') in a group of 54 freshmen, at zero acquaintance:

<<echo=true>>=
# load the package
library(TripleR)

# load a data set in long format
data(likingLong)

#inspect the data set
head(likingLong, 15)
@

As we can see, both liking and meta-liking have been assessed with two indicators, which allows a latent analyses. But first let's do an univariate analysis:

\subsection{Univariate manifest analysis} % (fold)
\label{sub:univariate_manifest_analysis}
All analyses can be run with one function: \texttt{RR}. For details, you definitely should check the help entry for this function (type \texttt{?RR} into the R console). Most parameters of the function are specified via a formula interface. The formula for the current analysis would be: \texttt{liking\_a \textasciitilde actor.id * partner.id}. The measured variables are defined in the left part of the formula (left of the \textasciitilde sign). The right part defines, which columns in the data frame indicate the actor, the partner, and the group id. These three variables are always given in this order. Actor and partner id are separated by a \texttt{*}, which indicates that these factors are fully crossed (as in the \texttt{lm} notation). The group id is separated by a \texttt{|}, as in the \texttt{lattice} notation.

After the formula, the data frame has to specified, on which the formula will be applied. Unlike as in the \texttt{lm} notation, the data object has to be specified explicitly by \texttt{data=...}. Hence, the final command for a univariate manifest analysis is:
\begin{center}
\texttt{RR1 <- RR(liking\_a \textasciitilde actor.id * partner.id, data=likingLong)}
\end{center}

Please note: all variable names in the formula (i.e., liking\_a, actor.id, and partner.id) refer to column names in the specified data frame. They do not have to be like this - if your data frame has other column names your formula might look like \texttt{DV~a*p}, or anything else.


When we run the command, an object of the class \texttt{RR} is returned. If we print the object, a summary of the analysis is printed:

<<echo=true>>=
RR1 <- RR(liking_a ~ actor.id * partner.id, data=likingLong)
RR1
@
% subsection univariate_manifest_analysis (end)




\subsection{Univariate latent analyses} % (fold)
\label{sub:univariate_latent_analyses}
If you have two indicators to assess a latent construct, error variance can be separated from relationship variance (in the univariate manifest case, error variance is mixed up in the relationship variance component). Two indicators for one latent construct are separated by a \texttt{/}. In the current data set, we have two indicators for liking, hence the analysis would look like:

<<echo=true>>=
RR2 <- RR(liking_a/liking_b ~ actor.id * partner.id, data=likingLong)
RR2
@

As you can see, the error variance component changed from NA to a meaningful value. For the error component no significance tests are provided. Furthermore, n the single group case we are not aware of an approach to calculate the significance of the latent covariances (in the multi group case, however, they can be calculated, see below).
% subsection univariate_latent_analyses (end)




\subsection{Bivariate manifest analysis} % (fold)
\label{sub:bivariate_manifest_analysis}
If you have two different variables (each assessing another construct), bivariate SRAs can be performed. Two different variables are separated by a \texttt{+} on the left hand side of the formula. In the current example, we can examined the relationship between liking and meta-liking, by typing:

<<echo=true>>=
RR3 <- RR(liking_a+metaliking_a ~ actor.id * partner.id, data=likingLong)
RR3
@

In this case, we get three different outputs: univariate analyses for each of the both variables, and a third section containing the bivariate analyses (i.e., all possible covariances between the social relations effects from both variables).
% subsection bivariate_manifest_analysis (end)



\subsection{Bivariate latent analysis} % (fold)
\label{sub:bivariate_latent_analysis}
In this case, two latent constructs are measured by two indicators each. In the current example, we have two indicators for liking and for metaliking. Applying the same logic as before, the command now is:
<<echo=true>>=
RR4 <- RR(liking_a/liking_b + metaliking_a/metaliking_b ~ actor.id * partner.id, data=likingLong)
RR4
@

Now we get a comparable output to the bivariate manifest analysis, only that now the error variance can be separated form the relationship variance.
% subsection bivariate_latent_analysis (end)



\subsection{Multiple groups} % (fold)
\label{sub:multiple_groups}
Using the formula interface, analyses with multiple groups can be performed as well. The only extension is, that the variable which identifies group membership is specified at the end of the formula after a \texttt{|} sign. For example, we load another built in data set which consists of 10 groups:

<<echo=true>>=
data(multiGroup)
RR1m <- RR(ex~actor.id*partner.id|group.id, data=multiGroup, na.rm=TRUE)
RR1m
@


Any formula explained above can be extended by the multi group parameter. Concerning the output, no differences can be seen (except the second line of the output, which always displays the type of analysis: \texttt{"Univariate analysis of one round robin variable in multiple groups"}). 

As already described, one computational difference is the usage of between group t-tests, instead of the within group method. Another difference is the results object: all univariate analyses are contained (although, not displayed by the \texttt{print} function) in the results. More details on the results object can be found in the next section.
% subsection multiple_groups (end)



\subsection{Missing values} % (fold)
\label{sub:missing_values}
Missing values can be handled in TripleR. For more information see the vignette TODO. By default, calculations are aborted if missing values are outside the diagonale of the round robin matrix. To allow missing values, add the argument \texttt{na.rm=TRUE}.
% subsection missing_values (end)



\subsection{Inspecting the results object} % (fold)
\label{sub:inspecting_the_results_object}
When a round robin analyses is performed (and stored in an object), not all information is displayed. When the object is printed (either by \texttt{print(object)}, or by simple writing the name of the object, e.g. \texttt{RR1}), a custom \texttt{print} function is called, which displays the table of variance components, effects reliability estimates, and some other information. During the calculation, however, much more results are computed and stored in the object.

To see the structure of the object type \texttt{str(object)}:

<<echo=true>>=
str(RR1)
@


Multiple data structures are stored in the object in list mode. Some objects are for internal use, others, however, are very important for subsequent analyses (see section \ref{sec:subsequent_analyses}).
You can access all stored objects via the \texttt{\$} operator. For example, the actor and partner effects are stored in the \texttt{effects} object:

<<echo=true>>=
head(RR1$effects)
@

Following data objects might be relevant for subsequent analyses:
\begin{description}
	\item[effects] The actor and partner effects. You access each effect by another \texttt{\$} operator, e.g. \texttt{RR1\$effects\$actor}
	\item[effects.gm] Actor and partner effects with group mean added
	\item[effectsRel] A data frame in long format which corresponds to the \texttt{n x n} matrix of relationship effects
	\item[varComp] A data frame with the absolute and standardized variance components and their respective significance tests (this object is printed int the \texttt{print} function of an \texttt{RR} object)
	\item[group.var] In the multi group case: display group variance
\end{description}

In section \ref{sec:subsequent_analyses} (Subsequent Analyses) it is explained how follow up analyses using the actor and partner effects, and the variance components can be done.
% subsection inspecting_the_results_object (end)






\section{Plots} % (fold)
\label{sec:plots}

Several plots can be made from the result objects. Simply type \texttt{plot(RR\_object)} to see the standard variance plot associated with each analysis. The main difference between plots is whether you have multiple groups or a single round robin group.

<<echo=true, eval=false>>=
# see Figure 1
plot(RR1)
@

\begin{figure} 
\begin{center} 
<<fig=true, echo=false>>=
print(plot(RR1))
@
\end{center}
\caption{Variance decomposition of a single round robin group}
\label{fig:one}
\end{figure}




<<echo=true, eval=false>>=
# see Figure 2
plot(RR1m)
@

\begin{figure} 
\begin{center} 
<<fig=true, echo=false>>=
print(plot(RR1m))
@
\end{center}
\caption{Variance decomposition of multiple round robin groups}
\label{fig:two}
\end{figure}


You can also try different parameters:
\begin{description}
	\item[measure] =\texttt{behavior} (default) or \texttt{perception}: changes the labels of the plots
	\item[geom (single groups)] = \texttt{bar} (default) or \texttt{pie}: show variance components as stacked bars or as a pie chart
	\item[geom (multiple groups)] = \texttt{scatter} (default) or \texttt{bar}: show variance components of all groups as scatter plots with confidence intervals or as a bar charts
	\item[connect (multiple groups)] = \texttt{FALSE} (default) or \texttt{TRUE}: connect the dots of each group in the scatter plot (usually this looks very cluttered and should not be turned on)
	\item[conf.level (multiple groups)] (defaults to 0.95) defines the size of the confidence interval in the scatter plot
\end{description}


Hence you can try several combinations of these parameters, e.g.:

<<eval=false, echo=true>>=
plot(RR1, measure="perception", geom="pie")
plot(RR1, measure="behavior", geom="pie")
plot(RR1m, measure="perception", geom="bar")
plot(RR1m, conf.level=0.5, connect=TRUE)
@


The plot function returns a \texttt{ggplot2} object, which in turn can be altered (e.g., you can change the title, the axes labels, the colors, etc.). For more information, please consult the \texttt{ggplot2} documentation.


% section plots (end)






\section{Formatting the output} 
As mentioned above, two nomenclatures have been established, depending on whether behaviors or interpersonal perceptions are assessed. While internally always the labels \emph{actor} and \emph{partner} are used, the summary output can be customized by specifying whether the measure is a \texttt{behavior} or a \texttt{perception} (default is \emph{behavior}). In bivariate analyses, both variables can be specified, e.g. \texttt{measure1=`behavior', measure2=`perception'}, or all other combinations, e.g.:

<<echo=true>>=
print(RR1, measure1="perception")
print(RR4, measure1="behavior", measure2="perception")
print(RR4, measure1="perception", measure2="metaperception")
@

Possible combinations are for the univariate case: \texttt{measure=c("behavior", "perception")}; and for the bivariate case: \texttt{measure1 = c("behavior", "perception")}, \texttt{measure2 = c("behavior", "perception")}, and the special case \texttt{measure1="perception", measure2="metaperception"}.

As you can see, typical labels from different research traditions, like `generalized reciprocity metaperception' or `perceiver meta-accuracy' are automatically printed to ease interpretation of the results.





\section{Subsequent analyses} % (fold)
\label{sec:subsequent_analyses}
Usually one does not only want to know about the variance components and the within-SRM correlations. Often, we want to correlate the actor and partner effects with the self-ratings, with external personality questionnaires, or demographic variables. To do this, we can extract the actor/ partner effects from the RR-object, combine them with the other data (e.g., self ratings) in another data frame, and do which ever analysis we like.

\emph{Be careful:} in RR objects one cannot be sure about the order and the completeness of actor/ partner effects. That means, actors can be reordered and their order might be different from that in the original data set. Furthermore, if some participants are only actors or only partners they are removed prior to to the social relations analyses, and do not appear in the actor/ partner effects. Hence, merging of RR effects and other data \emph{always} has to be done using the \texttt{merge} command (merging along the actor id).

The data set \texttt{multiGroup} contains round robin and also has self ratings of extraversion, which will serve as an extended example:

<<echo=true>>=

# calculate the SRM
data(multiGroup)
RR1m <- RR(ex~actor.id*partner.id|group.id, data=multiGroup, na.rm=TRUE, suffixes=c(".p", ".t"))
RR1m

# extract the actor and partner effects
eff <- RR1m$effects
head(eff)

# extract the self ratings from the raw data set
self <- multiGroup[multiGroup$actor.id == multiGroup$partner.id,]
str(self)

@ 


As actor and partner effects are corrected for group membership, according to Kenny et al. (2006) partial correlations should be used when these effects are correlated with external (non-SRM) variables (i.e. external variables like self ratings also have to be controlled for group membership). The easiest way to calculate partial correlations is to correlate the residuals of linear models where the variables are controlled for nuisance variables. In the SRM case, the group id is entered as a factor (factors automatically are dummy coded in \texttt{R}). As actor and partner effects from the \texttt{RR} output already are centered on the group mean, it is not necessary to compute the residuals for these variables. When calculating the significance of the correlation between the residuals, be aware that you lose one degree of freedom for each variable you control for (in the present case, we lose one extra \emph{df} for the group factor).

<<echo=true>>=
self$group.id <- factor(self$group.id)

# control self rating for group membership
self$ex.self.partial <- lm(ex~group.id, self)$resid

# target effects already are controlled for group membership, you can try:
# eff$ex.t.partial <- lm(ex.t~group.id, eff)$resid
# plot(eff$ex.t, eff$ex.t.partial)

# remove partner id column (it is identical to the actor id)
self <- self[,-c(2)]
colnames(self)[3:4] <- c("ex.self", "ne.self")
head(self)

# merge the SRA effects with the self ratings
# As the id column has different names in both data frames, 
# they have to be specified independently

#merging works better, if actor ids are factor mode
self$actor.id <- factor(self$actor.id)	
df <- merge(eff, self, by.x=c("id", "group.id"), by.y=c("actor.id", "group.id"))
head(df)

# correlate effects and self ratings
c1 <- cor(df$ex.t, df$ex.self.partial, use="p")

# Be careful: when calculating partial correlations, the degrees of freedom have to be adjusted
# For each variable you control for, you lose 1 df

#Calculate the t value by hand:
k <- 1			# k = number of control parameters
n <- nrow(df)	# n = number of participants
t.value <- c1*sqrt((n-2-k)/(1-c1^2))
p.value <- dt(t.value, df=n-2-k)
round(p.value, 2)

@

In this analysis, we find a considerable self-other agreement of extraversion ratings $r_{ex.target,ex.self}=.634$.


Using this approach suggested by Kenny et al. (2006), groups are treated as fixed factors. Both conceptually and by means of computations it might be preferable to treat groups as random factors (which, however, requires a sufficient number of groups). When using a multilevel approach, we would like to keep the group variance in our dependent variable (as the multilevel modeling takes care of this), hence we use the effects with group mean added (\texttt{effects.gm}) and the raw self ratings. Using a multilevel modeling approach, the calculation would look like the following:

<<echo=true>>=
library(lme4)

eff.gm <- RR1m$effects.gm
df2 <- merge(eff.gm, self, by.x=c("id", "group.id"), by.y=c("actor.id", "group.id"))
print(str(df2))
# scale all continuous variables to the grand mean to obtain standardized estimates
df3 <- df2
df3[,3:7] <- apply(df2[,3:7], 2, scale)

# allow the intercept to vary between groups
# (this is equivalent to the fixed effects approach of Kenny et al.)
lmer(ex.self~ex.t + (1|group.id), df3)

# also allow slopes to vary between group:
lmer(ex.self~ex.t + (ex.t|group.id), df3)

@


The multilevel analysis reveals a self-other agreement of extraversion ratings $\beta_{ex.target,ex.self}=.630$. As there is no random variance of the group level in this analysis (neither for intercepts nor slopes), the result is virtually the same as in the fixed effects analysis. 

For principal reasons, the \texttt{lme4} package does not report p values, as it is not clear how to compute the degrees of freedoms in multilevel models\footnote{https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html, also see several lengthy discussions on the R-sig-ME mailing list}. 
For practical reasons, however, with sufficient degrees of freedom the \emph{t} distribution converges to the \emph{z} distribution. Hence, the reported \emph{t} value still can be examined. Some authors argue that absolute \emph{t} values > 2 can be judged as significant, regardless of the actual \emph{df} (e.g., \citeNP{Baayen2008,Kliegl2010}).


Relationship effects have, in contrast to actor and partner effects, another structure: they are nested in each dyad, which implies a multilevel structure even in a single round robin group. Hence, in this case a APIM or other multilevel method has to be employed.


Correlations which are calculated by SOREMO.exe are by default disattenuated for actor and/or partner effect unreliability. To replicate these results, you have to disattenuate the obtained correlations by following formula:

$r_{disatt} = r_{raw}*\frac{1}{\sqrt{Rel_{target effect}}}$


% section subsequent_analyses (end)



\section{FAQ} % (fold)
\label{sec:faq}



\subsection{This is an excellent introduction - but where can I get more information or pose a question?} % (fold)
\label{sub:this_is_an_excellent_introduction___but_where_can_i_get_more_information_or_pose_a_question_}
The best way is to join the tripler-info mailing list on R-Forge. Bug reports, questions, or praise can be put on this list; important announcements (new versions, functions, etc.) also are posted on this list:\\http://lists.r-forge.r-project.org/mailman/listinfo/tripler-info
% subsection this_is_an_excellent_introduction___but_where_can_i_get_more_information_or_pose_a_question_ (end)




\subsection{How can I calculate a bivariate analysis between one manifest variable and a latent construct indicated by two variables?} % (fold)
\label{sub:how_can_i_calculate_bivariate_between_one_manifest_variable_and_a_latent_construct_indicated_by_two_variables_}
A natural application of the formula interface would be:

\begin{center}
\texttt{RR1 <- RR(liking\_a + metaliking\_a / metaliking\_b \textasciitilde actor.id * partner.id, data=likingLong)}
\end{center}


This approach, however, does not work in the current version of TripleR. However, you can do the analysis by first creating a new variable for the latent construct by taking the mean of both indicators for metaliking. Then, you can perform a normal bivariate manifest analysis:

\begin{center}
\texttt{RR1 <- RR(liking\_a + metaliking\_latent \textasciitilde actor.id * partner.id, data=likingLong)}
\end{center}

% subsection how_can_i_calculate_bivariate_between_one_manifest_variable_and_a_latent_construct_indicated_by_two_variables_ (end)



\subsection{This long data format really sounds good. But unfortunately my data already are in the wide format - how can I convert them into the long format?} % (fold)
\label{sub:this_long_data_format_really_sounds_good_but_unfortunately_my_data_already_are_in_the_wide_format_how_can_i_convert_them_into_the_long_format_}

Converting data from wide to long is relatively easy in R. If you have quadratic matrices, TripleR provides a function which converts these data into long format. For example, in the package is a built in data set (\texttt{liking\_a}), which is in wide format:

<<echo=true>>=
data(liking_a)
head(liking_a)
@

To convert this into long format you can use the function \texttt{matrix2long}:

<<echo=true>>=
long <- matrix2long(liking_a)
str(long)
@

Now you can run the SRAs as usual using the data frame \texttt{long}. If you assessed multiple variables (and now have a separate matrix for each variable), you have to get each variable into long format and then combine all long data frames using \texttt{merge} (in the final data frame, each variable should be a separate column):

<<>>=
data(liking_a)
data(liking_b)
long_a <- matrix2long(liking_a, var.id="liking_a")
long_b <- matrix2long(liking_b, var.id="liking_b")

long <- merge(long_a, long_b, by=c("actor.id", "partner.id"))

str(long)
@


If you have multiple groups, all transformed long data frames are combined \emph{row wise} and an additional column is necessary to indicate the group id. In lack of appropriate demo data, for the following example imagine that \texttt{liking\_a} is the liking rating in group A, and \texttt{liking\_b} is the liking rating in another group B. Hence, one would combine both as following:

<<echo=true>>=
data(liking_a)
data(liking_b)
long_a <- matrix2long(liking_a, var.id="liking")
long_b <- matrix2long(liking_b, var.id="liking")

# add group id
long_a$group.id <- 1
long_b$group.id <- 2

long2 <- rbind(long_a, long_b)
str(long2)
@

Be careful: \texttt{rbind} only works if all column names are identical in the data frames which are combined. Hence, you have to make sure that all long data frames have the same structure before applying \texttt{rbind} to them. Furthermore, you should note that performing \texttt{RR} in this last example is not overly sensible, as running a between group t-test with only two groups is rather debatable.

The function \texttt{matrix2long} essentially is a wrapper for the much more powerful functions from the \texttt{reshape} package. If you do a lot of data manipulation and conversions from wide to long format or vice versa, you definitely should dig into this package.
% subsection this_long_data_format_really_sounds_good_but_unfortunately_my_data_already_are_in_the_wide_format_how_can_i_convert_them_into_the_long_format_ (end)






\subsection{I have to run many, many round robin analyses in a huge data set. What is the most convenient way to do this?} % (fold)
\label{sub:i_have_to_run_many_many_round_robin_analyses_in_huge_data_set_what_is_the_most_convenient_way_to_do_this_}
Imagine you assessed 50 variables in round robin style, and want to extract the effects for all variables and to store them in a new data frame (e.g., for subsequent analyses). Of course, you can type the \texttt{RR} command 50 times, but there are more convenient ways to do this.

You can construct the formula by a loop, and iterate through all measured variables, and combine the results at the end. As an example, let's take the \texttt{likingLong} data set, which has 4 round robin variables:

<<echo=true>>=
data(likingLong)
str(likingLong)
@

If we want to extract the effects for all 4 variables, we could either type:

<<echo=true,results=hide>>=
RR(liking_a~actor.id*partner.id, data=likingLong)
RR(liking_b~actor.id*partner.id, data=likingLong)
RR(metaliking_a~actor.id*partner.id, data=likingLong)
RR(metaliking_b~actor.id*partner.id, data=likingLong)
@


Or, we do it in a loop, store the results and combine them at the end:

<<label=merging, echo=true>>=
varnames <- colnames(likingLong)[3:6]

# run a RR analysis for each variable and store results in a list
res_list <- list()
for (v in 1:length(varnames)) {
	f1 <- formula(paste(varnames[v], "~actor.id*partner.id"))
	RR1 <- RR(f1, data=likingLong)
	res_list <- c(res_list, list(RR1$effects))
}


# now combine all effects in a single data frame; merge by id
library(reshape)
res <- merge_recurse(res_list, by="id")
@ 


As you can see, there's a new data frame with all actor and partner effects. On this data frame you can run subsequent analyses, for example correlations:

<<echo=true>>=
str(res)

round(cor(res[,2:9]), 2)
@


For convenience, this short script is also implemented in TripleR (\texttt{?getEffects}), which reduces the code to one or two lines:

<<echo=true>>=
res <- getEffects(~actor.id*partner.id, data=likingLong, 
				varlist=c("liking_a", "liking_b", "metaliking_a", "metaliking_b"))
str(res)
@



% subsection i_have_to_run_many_many_round_robin_analyses_in_huge_data_set_what_is_the_most_convenient_way_to_do_this_ (end)




\subsection{An error occurs: `Aggregation requires fun.aggregate: length used as default'} % (fold)
\label{sub:an_error_occurs_aggregation_requires_fun_aggregate_length_used_as_default_}
This error most probably occurs when you specify a data set which has a multi group structure, but you forgot to define the group id in the formula (i.e., the \texttt{| group.id} part is missing).
% subsection an_error_occurs_aggregation_requires_fun_aggregate_length_used_as_default_ (end)






\subsection{My original multi group data set has X participants - the effects of the RR analysis, however, only have Y (Y < X) rows!} % (fold)
\label{sub:my_original_multi_group_data_set_has_x_participants_the_effects_of_the_rr_analysis_hiow}
This happens, whenever single groups are excluded from the SRA. SRAs need a minimum group size of 4 participants. If your data set contains groups with 3 or fewer members, this group is excluded from the analyses, and no effects are calculated. A warning message informs you which groups have been excluded.
% subsection my_original_multi_group_data_set_has_x_participants_the_effects_of_the_rr_analysis_hiow (end)




\subsection{An example from David Kenny - Comparison with SOREMO.exe} % (fold)
\label{sub:an_example_from_david_kenny}
David Kenny describes how to estimate SRMs with other software programs \\(http://www.davidakenny.net/doc/srmsoftware.doc) and also provides a data set. We can do the analysis in TripleR as well:

<<echo=true>>=
library(TripleR)
library(foreign)

dat <- read.spss("http://www.davidakenny.net/doc/contribute.sav", to.data.frame=TRUE)
RR.Kenny <- RR(l1~Actor*Partner|Group, data=dat)
RR.Kenny
@

Group variance is not printed in the standard \texttt{RR}-output, but it can be accessed by:

<<echo=true>>=
RR.Kenny$group.var
@

If you compare these results with Table 1 from the \texttt{srmsoftware.doc} document, you will see that all results are identical to SOREMO.
% subsection an_example_from_david_kenny (end)


% section faq (end)



\bibliographystyle{apacitex}
\bibliography{TripleR}

\end{document}
